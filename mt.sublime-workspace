{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Lae",
				"LabelMap"
			],
			[
				"Fea",
				"FeatureMap"
			],
			[
				"mergr",
				"mergeGraphPtrs_"
			],
			[
				"gra",
				"graphPtrs_"
			],
			[
				"use",
				"usepackage"
			],
			[
				"Ad",
				"AdjacencyListGraph"
			],
			[
				"Merge",
				"MergeGraph"
			],
			[
				"foot",
				"footnote"
			],
			[
				"descr",
				"descriptor"
			],
			[
				"lst",
				"lstinline"
			],
			[
				"mergeNodeCall",
				"MergeNodeCallBack"
			],
			[
				"modif",
				"modified"
			],
			[
				"Adja",
				"AdjacencyListGraph"
			],
			[
				"imple",
				"implementation"
			],
			[
				"merge",
				"mergeGraph"
			],
			[
				"adju",
				"adjusted_rand_score"
			],
			[
				"gauss",
				"gaussianGradientMagnitude"
			],
			[
				"values",
				"valuesMin"
			],
			[
				"ind",
				"indices"
			],
			[
				"gamma",
				"gammas"
			],
			[
				"fot",
				"footnote"
			],
			[
				"exca",
				"exactly"
			],
			[
				"des",
				"descriptors"
			],
			[
				"corr",
				"corresponds"
			],
			[
				"descri",
				"descriptors"
			],
			[
				"coor",
				"coordinates"
			],
			[
				"corres",
				"corresponds"
			],
			[
				"tikz",
				"tikzpicture"
			],
			[
				"explicit",
				"explicitly"
			],
			[
				"vers",
				"versa"
			],
			[
				"vigra",
				"vigranumpy"
			],
			[
				"consi",
				"considered"
			],
			[
				"nodeNum",
				"nodeNumStop"
			],
			[
				"archv",
				"archive"
			],
			[
				"str",
				"struct"
			],
			[
				"appl",
				"applied"
			],
			[
				"Hie",
				"HierarchicalClustering"
			],
			[
				"Water",
				"Watersheds"
			],
			[
				"Aj",
				"AdjacencyListGraph"
			],
			[
				"my_e",
				"my_module"
			],
			[
				"MergeGraph",
				"MergeGraphAdpator"
			],
			[
				"Hier",
				"HierachicalClustering"
			],
			[
				"adja",
				"adjacency"
			],
			[
				"export_gra",
				"export_graph_shortest_path_visitor"
			],
			[
				"export",
				"export_graph_algorithm_visitor"
			],
			[
				"dark",
				"darkred"
			],
			[
				"Edge",
				"EdgeIt"
			],
			[
				"Val",
				"ValueType"
			],
			[
				"NodeMa",
				"NodeMaps"
			],
			[
				"cet",
				"centering"
			],
			[
				"Adj",
				"AdjacencyListGraph"
			],
			[
				"python",
				"Python"
			],
			[
				"Lemon",
				"LEMON"
			],
			[
				"contr",
				"constraints"
			],
			[
				"relax",
				"relaxation"
			],
			[
				"cons",
				"consistency"
			],
			[
				"Pro",
				"Programming"
			],
			[
				"const_",
				"const_iterator"
			],
			[
				"impl",
				"implemented"
			],
			[
				"impleme",
				"implementation"
			],
			[
				"uner",
				"uncertainty"
			],
			[
				"cent",
				"centering"
			],
			[
				"arg",
				"argmin_"
			],
			[
				"watershe",
				"watersheds"
			],
			[
				"water",
				"watersheds"
			],
			[
				"al",
				"align"
			],
			[
				"u",
				"u_i"
			],
			[
				"uni",
				"unique"
			],
			[
				"exa",
				"exactly"
			],
			[
				"implementato",
				"implementations"
			],
			[
				"Mult",
				"MultiArrays"
			],
			[
				"implem",
				"implemented"
			],
			[
				"lof",
				"lofthumbsize"
			],
			[
				"featu",
				"features"
			],
			[
				"VIGRA",
				"VIGRA's"
			],
			[
				"ls",
				"lstinline"
			],
			[
				"feature",
				"featuresInMap"
			],
			[
				"Hi",
				"HierarchicalClustering"
			],
			[
				"multi",
				"multicut"
			],
			[
				"mult",
				"multicuts"
			],
			[
				"ce",
				"centering"
			],
			[
				"f",
				"fig"
			],
			[
				"disc",
				"discussed"
			],
			[
				"l",
				"lstinline"
			],
			[
				"desc",
				"descriptor"
			],
			[
				"add",
				"addition"
			],
			[
				"fote",
				"footnotesize"
			],
			[
				"softwe",
				"software_vigra"
			],
			[
				"data",
				"datastructures"
			],
			[
				"ar",
				"arbitrary"
			],
			[
				"simpl",
				"simplify"
			],
			[
				"algor",
				"algorithms"
			],
			[
				"algo",
				"algorithms"
			],
			[
				"ana",
				"analysis"
			],
			[
				"prco",
				"processing"
			],
			[
				"adjac",
				"adjacent"
			],
			[
				"diff",
				"different"
			],
			[
				"ME",
				"MEX"
			],
			[
				"WATER",
				"Watersheds"
			],
			[
				"desri",
				"desirable"
			],
			[
				"widt",
				"width"
			],
			[
				"fi",
				"figure	Figure"
			],
			[
				"equ",
				"equivalently"
			],
			[
				"sin",
				"sinop_2007_iccv"
			],
			[
				"strcutr",
				"structures"
			],
			[
				"For",
				"Formulation"
			],
			[
				"min",
				"minipage"
			],
			[
				"corre",
				"corresponding"
			],
			[
				"segment",
				"segmentation"
			],
			[
				"inc",
				"includegraphics"
			],
			[
				"fig",
				"figure"
			],
			[
				"hierac",
				"hierarchy"
			],
			[
				"struc",
				"structures"
			],
			[
				"provi",
				"provides"
			],
			[
				"impe",
				"implemented"
			],
			[
				"compat",
				"compactitem"
			],
			[
				"Orgi",
				"Organization"
			],
			[
				"solu",
				"solutions"
			],
			[
				"nei",
				"neighboring"
			],
			[
				"adjace",
				"adjacency"
			],
			[
				"ap",
				"applied"
			],
			[
				"make",
				"fig:make_rag"
			],
			[
				"make_r",
				"fig:make_rag_grid"
			],
			[
				"figu",
				"figure"
			],
			[
				"adj",
				"adjacency"
			],
			[
				"text",
				"textwidth"
			],
			[
				"tex",
				"textwidth"
			],
			[
				"hi",
				"hierarchical"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "% !TEX root = ../../main.tex\n\n\n\\section{Implementation}\\label{sec:vigra_graph_lib_impl}\n\n\\todo{Impl is not a good word here}\n\nThe most important concept for graph based image processing\nis the \\emph{region adjacency graph} (RAG) (see \\cref{fig:make_rag}).\n\nA RAG is extracted from a labeled \\emph{base graph}.\nIn the first step of graph based image processing, the base \ngraph is usually a grid graph, and the labeling is a label image\nas in \\cref{fig:make_rag} .\nTo encode a RAG we need a undirected graph, \nand a mapping from the base graphs edges and nodes to the RAG \nneeds to be stored.\n\nThe implementation of grid graphs is explained in \\cref{sec:graphs_grid_graph}, \na basic undirected graphs implementation will be discussed in \\cref{sec:graphs_adjacency_list_graph}.\nThe implementation details of the \\emph{region adjacency graph} concept will \nbe given in  \\cref{sec:graphs_rag}.\n\nFor hierarchical clustering we provide a specialized graph, named \\emph{merge graph}.\n\n\nTo implemented structured clustering algorithms (see \\cref{sec:rw_hc}) we\nneed a graph which supports the contraction of edges.\nAlso a mechanism to merge node and edge features is needed.\nWithin \\cref{sec:graphs_merge_graph} we propose  a very flexible graph \ncalled \\emph{merge graph adaptor} which fulfills these requirements.\n\n\nA generic set of algorithms which work on any graph\nimplemented within the VIGRA graph api is presented \nin \\cref{sec:graph_graph_algorithms}.\n\nWhile the core implementation of any algorithm is in C++\nVIGRA provides python binding to make almost\nany algorithm available in Python.\nTo provide a generic Python interface for any proposed\ngraph, we need to introduce a few concepts \nto make the python wrapped graph API very \\emph{Pythonic}\n\n\n%$\\surd \\bullet$\n\n\n\\begin{table}\n\\begin{tiny}\n\\begin{tabular}{|l|p{1.5cm}|p{0.5cm}|p{0.5cm}|p{0.6cm}|p{0.6cm}|p{0.6cm}|p{0.8cm}|p{0.8cm}|l|l|l|}\n    \\hline \n    Class & purpose & \n        add nodes & add edges & contract edges & node ids & edge ids & \n        node descriptor & edge descriptors &\n        node map & edge map  &\n        header\n    \\\\ \\hline\n    %\n    2D-GridGraph & implicit graph for 2D images & \n        x & x & x & dense & sparse & \n        $\\colvec{x\\\\y}$ &  $\\colvec{x\\\\y\\\\e}$ & \n        2D-Array & 3D-Array   &\n        \\detokenize{multi_gridgraph.hxx}\n    \\\\ \\hline\n    %\n    3D-GridGraph & implicit graph for 3D volumes & \n        x & x & x & dense & sparse & \n        $\\colvec{x\\\\y\\\\z}$ &  $\\colvec{x\\\\y\\\\z\\\\e}$ & \n        3D-Array & 4D-Array   &\n        \\tiny{\\detokenize{multi_gridgraph.hxx}}\n    \\\\ \\hline\n    %\n    4D-GridGraph & implicit graph for 3D volumes $+$ time & \n        x & x & x & dense & sparse & \n        $\\colvec{x\\\\y\\\\z\\\\t}$ &  $\\colvec{x\\\\y\\\\z\\\\t\\\\e}$ & \n        4D-Array & 5D-Array   &\n        \\detokenize{multi_gridgraph.hxx}\n    \\\\ \\hline\n    %\n    AdjacencyListGraph & multi purpose graph & \n       $\\bullet$  & $\\bullet$ & x & maybe dense & dense & \n       $\\colvec{n}$ , same as node id &  $\\colvec{e}$  , same as edge id & \n       1D-Array & 1D-Array   &\n       \\detokenize{adjacency_list_graph.hxx}\n    \\\\ \\hline\n    %\n    MergeGraphAdpator & edge contraction with feature merging callback & \n       x & x & $\\bullet$& sparse & sparse & \n       $\\colvec{n}$ , same as node id &  $\\colvec{e}$ , same as edge id & \n       1D-Array & 1D-Array   &\n       \\detokenize{merge_graph_adaptor.hxx}\n    \\\\ \\hline\n\\end{tabular}\n\\end{tiny}\n\\end{table}\n\\subsection{Graphs}\n\n\\subsubsection{Grid Graph} \\label{sec:graphs_grid_graph}\n\nThe grid graph implemented in VIGRA is N-dimensional.\nThe dimension can be selected with templates, and therefore with zero\noverhead.\n\nDue to the regular structure of a grid graph, it is possible to compute the edges of a given \nnode and vice versa on the fly, instead of storing these relations explicitly.\nTherefore a grid graph can be implemented with almost zero memory overhead.\n\n\\paragraph{Node Descriptor/Id :}\nThe node descriptor of a grid graph is implemented as a\n$N$-dimensional coordinate of the pixel which corresponds to\nthat particular node. The id of a node is the scan order index\nof the corresponding pixel.\nAs a consequence, node id's of a grid graph are continuous.\n\\paragraph{Edge Descriptor/Id :}\nTo edge descriptors are implemented as $N+1$-dimensional coordinate.\nThe first $N$ axis correspond to the node which ``owns'' this edge.\nThe last axis enumerates the edge w.r.t. the node.\n\nIn a grid graph, all nodes have the same degree, except for nodes\nat the border of the image.\nThis breaks somehow the regularity of grid graphs.\nTo still have very regular structure, edge ids\nare enumerated, as if the graph would be perfectly\nregular. Therefore we enumerate some missing edges\nat the border and get non-continuous edge ids.\n\\Cref{fig:grid_graph_ids} illustrates this enumeration.\n\n\n\n\\begin{figure}[H]\n\\centering\n\\begin{tikzpicture}[scale=0.7,transform shape]\n  % virtual nodes\n  \\draw (-2*2,0) node (naa) {$\\quad$};\n  \\draw (-2*2,2*2) node (nbb) {$\\quad$};\n  \\draw (0,4*2) node (na) {$\\quad$};\n  \\draw (2*2,4*2) node (nb) {$\\quad$};\n  \\draw (4*2,4*2) node (nc) {$\\quad$};\n  % real nodes\n  \\draw (0,0) node[draw,circle,fill=blue!17] (n3) {$3_{(0,1)}$};\n  \\draw (2*2,0) node[draw,circle,fill=green!17] (n4) {$4_{(1,1)}$};\n  \\draw (4*2,0) node[draw,circle,fill=red!17] (n5) {$5_{(2,1)}$};\n  \\draw (0,2*2) node[draw,circle,fill=yellow!17] (n0) {$0_{(0,0)}$};\n  \\draw (2*2,2*2) node[draw,circle,fill=pink!17] (n1) {$1_{(1,0)}$};\n  \\draw (4*2,2*2) node[draw,circle,fill=magenta!17] (n2) {$2_{(2,0)}$};\n  %\n  % real edges\n  \\path[every node/.style={auto=false}]\n    (n0) edge node[draw,rectangle,fill=pink!17] {$7_{(1,0,1)}$} (n1) \n    (n1) edge node[draw,rectangle,fill=magenta!17] {$8_{(2,0,1)}$} (n2) \n    (n3) edge node[draw,rectangle,fill=green!17] {$10_{(1,1,1)}$} (n4) \n    (n4) edge node[draw,rectangle,fill=red!17] {$11_{(2,1,1)}$} (n5);\n \\path[every node/.style={auto=false}]\n    (n0) edge node[draw,rectangle,fill=blue!17] {$3_{(0,1,0)}$} (n3) \n    (n1) edge node[draw,rectangle,fill=green!17] {$4_{(1,1,0)}$} (n4) \n    (n2) edge node[draw,rectangle,fill=red!17] {$5_{(2,1,0)}$} (n5) ;\n  %\n  %virtual edges x\n  \\path[every node/.style={auto=false}]\n    (n0) edge[dashed] node[draw,rectangle,fill=yellow!17] {$0_{(0,0,0)}$} (na) \n    (n1) edge[dashed] node[draw,rectangle,fill=pink!17] {$1_{(1,0,0)}$} (nb) \n    (n2) edge[dashed] node[draw,rectangle,fill=magenta!17] {$2_{(2,0,0)}$} (nc) ;\n  \\path[every node/.style={auto=false}]\n    (n0) edge[dashed] node[draw,rectangle,fill=yellow!17] {$6_{(0,0,1)}$} (nbb) \n    (n3) edge[dashed] node[draw,rectangle,fill=blue!17] {$9_{(0,1,1)}$} (naa) ;\n   %\n   \\draw (-1.0,5.0) --  (9,5.0) -- (9,-1.0) -- (-1.0,-1.0) -- cycle;\n\\end{tikzpicture}\n\\caption[Grid Graph Ids]{ \\label{fig:grid_graph_ids}\n    Ids and descriptors for a 2D Grid graph with 4-neighborhood on a $3x2$ grid.\n    The node ids are continuous from $0$ to $5$ and the descriptors\n    are showed as subscripts of the ids.\n    Node descriptors are 2D pixel coordinates.\n    To get the edge ids, we enumerate the edge, but we ignore the fact that nodes at the\n    left and upper border do\n    not have an upper and left edge.\n    To illustrate this, these ``virtual'' edges are shown dotted.\n    The id's of the edges correspond to the enumeration.\n    As a consequence edge ids are non continuous.    \n    In this examples, \n    the set of valid edge ids is $\\{ 3,4,5,7,8,10,11 \\}$.\n    Edge descriptors are 3D coordinates, where the first two\n    coordinate correspond to the node which owns this edge.\n    The third coordinate is the edge number w.r.t. the node.\n    The two edges and the node which ``owns'' them are\n    shown in the same unique color.\n\n}\n\\end{figure}\n\n\\paragraph{Node Map :} An regular N-dimensional image can\nbe used as node map, and since node descriptors are plain\ncoordinates, they can be used to access data at a\nparticular pixel.\nThis means, no node map needs to be allocated for a given\nimage, since the image itself can be used as a node map.\nThe default node map is derived from \\lstinline{vigra::MultiArray<DIM,T>}.\n\n\\paragraph{Edge Map :} An N+1-dimensional image is\nused as edge map.\nThis image has the same as a node map, but an extra\ndimension for the edges.\nThe first $N$ axis in the edge descriptor are \nused to determine which pixel ``owns'' the edge,\nwhile the last axis select the w.r.t. the node.\nThe default edge map is derived from \\lstinline{vigra::MultiArray<DIM,Multiband<T> >}.\n\n\\paragraph{Usage :}\n    ...write me\n\\subsubsection{Adjacency List Graph} \\label{sec:graphs_adjacency_list_graph}\n\n\\paragraph{Node Descriptor/Id :}\nThe node descriptor is implemented as a simple class\nholding a single integer which is the id \nof the node.\nThe user can explicitly choose the id of\nan node. As a consequence, node id's can \nbe sparse and continuous.\n\n\\paragraph{Edge Descriptor/Id :}\nThe edge descriptors are implemented exactly like\nnode descriptors, but users cannot give\nedges explicit id's.\nTherefore edge id's are dense, unless\nedges are removed from the graph \\footnote{Removing edges from the graph is\nnot yet implemented}.\n\n\\paragraph{Node Map, EdgeMap:} \nThe node and edge maps are derived from \\lstinline{vigra::MultiArray<1,T>}.\nTheir size is to \\lstinline{maxNodeId()+1} and  \\lstinline{maxEdgeId()+1}.\nThe id and the descriptors can be used to index node and edge maps.\n\n\n\\paragraph{Usage :}\n    \\begin{lstlisting}[language=c++]\n    typedef vigra::AdjacencyListGraph Graph;\n    Graph g;\n\n    // add nodes \n    // - automatic id\n    // - explicit id\n    Graph::Node n0 = g.addNode() \n    Graph::Node n3 = g.addNode(3)\n\n    // add edges from existing nodes\n    // and new nodes\n    // no parallel edges \n    Graph::Edge e0 = g.addEdge(n0,n1)\n    Graph::Edge e1 = g.addEdge(2,3)\n    Graph::Edge e2 = g.addEdge(2,3)\n    assert(e1==e2)  \n    \\end{lstlisting}\n\n    \\begin{lstlisting}[language=Python]\n    g=vigra.graphs.listGraph();\n    # add nodes \n    # - automatic id\n    # - explicit id\n    n0 = g.addNode() \n    n3 = g.addNode(3)\n\n    # add edges from existing nodes\n    # and new nodes\n    # no parallel edges \n    e0 = g.addEdge(n0,n1)\n    e1 = g.addEdge(2,3)\n    e2 = g.addEdge(2,3)\n    assert e1==e2  \n    \\end{lstlisting}\n\\subsubsection{Region Adjacency Graph} \\label{sec:graphs_rag}\n\nA region adjacency is always defined w.r.t. a labeled base graph.\nInstead of implementing a new graph for RAG, we use\nthe \\emph{adjacency list graph}.\nThe mapping from base graph nodes and RAG nodes  is defined\nby the labeling itself. Therefore\nThe labeling defines a forward mapping from base graph nodes\nto RAG Node ids.\nA dense labeling \nEdges in the RAG are mapped to multiple edges in the base graph\nvia a backward mapping.\n\n\n\n\n\\subsubsection{Merge Graph} \\label{sec:graphs_merge_graph}\n\nTo implemented structured clustering algorithms (see \\cref{sec:rw_hc} ) \nA graph which supports edge contraction and feature merging is needed.\nSome graphs within the LEMON library support \nedge contraction, but this is not part of LEMON undirected graph concept \\footnote{\nEdge contraction cannot be a part of LEMON undirected graph concept,since some graphs\nare not mutable.}.\n\n\\begin{figure}[H]\n    \\centering\n    \\includegraphics[width=0.35\\textwidth]{fig/contraction.pdf}\n\n    \\addtocontents{lof}{%\n        \\vspace{1cm}\n        \\protect\\centerline{%\n            \\protect\\includegraphics[width=\\lofthumbsize,height=\\lofthumbsize,keepaspectratio=true]{fig/contraction.pdf} \n        } \n\n    }%\n    \\caption[Schematic edge contraction]{ Schematic edge contraction: Node $u$ and $v$ is merged into node $w$.\n        Note the gray node $n$ which is connected to $u$ and $v$.\n        After the contraction, edges $\\{ n,u\\}$ and $\\{ n,v\\}$ are also merged into \n        a single edge $\\{ n, w\\}$.\n        The picture has been taken from \\citep{wiki_edge_contraction} and has been modified slightly.\n    }\n    \\label{fig:figlabel}\n\\end{figure}\n\n\nFurthermore LEMON does not define any concept for feature merging, which\nis crucial for image processing application \\citep{arbelaez_2006_cvpr}.\nAs a consequence, we define a new concept / API for \nedge contraction and feature merging within the philosophy of LEMON.\n\nWe implemented the \\emph{merge graph} as an LEMON  \\href{http://lemon.cs.elte.hu/pub/doc/latest/a00592.html}{graph adaptor}\n\\footnote{ LEMON Graph Adaptor: \\url{http://lemon.cs.elte.hu/pub/doc/latest/a00592.html} }.\nA graph adaptor is aways a viewing to a base graph and cannot exist without one.\nA subgraph adaptor can used to get view to a subgraph w.r.t. the base graph, without\nthe need to reallocate the complete subgraph.\nIn a similar manner, we implement a \\emph{merge graph adaptor}.\n\nEach node and edge in the merge graph adaptor corresponds to a connected component of \nedge and nodes in the base graph.\nTwo union find data structure (UFD), and edge and node ufd encode these connected components.\n\nFeature merging is done via \\emph{callbacks} which can be registered to the merge graph adaptor.\nThe \\emph{callback API} is explained in detail below. \n\n\n\\begin{figure}[H]\n\\begin{center}\n    \\begin{tikzpicture}[scale=0.65,transform shape]\n        \\umlclass[template=Graph]{MergeGraphAdpator}\n        {\n            - edgeUfd               : IterablePartiton          \\\\\n            - nodeUfd               : IterablePartiton          \\\\ \n            - nodesAdjacency        : AdjacencySetVector        \\\\\n            - baseGraph             : Graph                     \\\\\n            - mergeNodeCallBacks    : MergeNodeCallBackVector   \\\\\n            - mergeEdgeCallBacks    : MergeEdgeCallBackVector   \\\\\n            - eraseEdgeCallBacks    : EraseEdgeCallBackVector   \n        }\n        {\n            // LEMON API for undirected graphs                  \\\\\n                $\\ldots$                                        \\\\\n            // register callbacks                               \\\\ \n            + registerMergeNodeCallBack(f : MergeNodeCallBack)  \\\\\n            + registerMergeEdgeCallBack(f : MergeEdgeCallBack)  \\\\\n            + registerEraseEdgeCallBack(f : EraseEdgeCallBack)  \\\\\n            // modify graph                                     \\\\\n            + contractEdge(edge : Edge)     : Node              \\\\\n            // find representatives                             \\\\\n            + reprNode(node : Graph::Node)  : Node              \\\\\n            + reprEdge(edge : Graph::Node)  : Edge              \\\\ \n            // get base graph                                   \\\\\n            + graph()                       : Graph             \\\\\n        } \n    \\end{tikzpicture}\n\\end{center}\\caption[Merge Graph Adaptor Class Diagram]{ \\label{fig:cls_mga}\n    Merge Graph Adaptor Class Diagram.\n    Only member functions which are not part of the LEMON\n    undirected graph concept are listed. \n    See \\cref{fig:uml_lemon_graph_concepts} for all missing \n    members.\n}\n\\end{figure}\n\n\n\n\\paragraph{Node Descriptor/Id :}\nThe node descriptor is implemented as a simple class\nholding a single integer which is the id \nof the node.\nEach node in the merge graph encodes a connected\ncomponent of nodes in the base graph.\nIf no edge has been contracted, the node ids\nof the merge graph are identical with the ids \nof the base graph.\nThe contraction of a single edge will invalidate\none node id, since two nodes are merged into a single \nnode.\nThe connected component membership of base graph\nnodes is stored in a union find data structure \nand can be accessed via \\lstinline{MergeGraph::reprNode(const BaseGraphNode & baseGraphNode)}.\n\n\n\\paragraph{Edge Descriptor/Id :}\nEdge descriptors are implemented as node descriptors.\nThe contraction of a single edge will invalidate\nat least one edge id, since the contracted edge is removed\nfrom the graph.\nBut contracting a single edge can lead to an\nunbounded number of parallel edges / multi edges.\nMultiple edges between a pair of nodes will be merged\ninto single edges.\nThe connected component membership of base graph\nedges is stored in a union find data structure \nand can be accessed via \\lstinline{MergeGraph::reprEdge(const BaseGraphEdge & baseGraphEdge)}.\nThis is only defined if $u,v$-nodes of this edge are in different connected components.\n\n\n\n\\paragraph{Node Map, EdgeMap :} \nThe node and edge maps are derived from \\lstinline{vigra::MultiArray<1,T>}.\nTheir size is to \\lstinline{maxNodeId()+1} and  \\lstinline{maxEdgeId()+1}.\nThe id and the descriptors can be used to index node and edge maps.\nThe implementation is exactly the same as for the AdjacencyListGraph \\Cref{sec:graphs_adjacency_list_graph}.\nThe default implementation of node and edge maps does not perform \nany feature merging since the merging strategy depends on the\nfeatures and the application itself.\nTo perform feature merging the merge graph uses a callback API which is explained below.\n\n\n\\paragraph{Callback API :}\n\nTo merge features the merge graph uses three different callbacks types.\nAny of these callbacks is implemented within boosts API for callbacks \\citep{ boost_function}\n\\footnote{\nCurrently we use the boost implementation for callbacks, but \nin the future we might use a faster implementation with the same API  \\citep{code_project_function}.\n}.\n\n\n\\begin{compactitem}\n\\item Merge node callback :\n    A contraction of an edge merges the two nodes of the edge\n    into a single node.\n    To merge node features a callbacks with the following signature \n    can be registered to the merge graphs merge node callback vector.\n    \\\\\n    \\lstinline[language=c++]{void mergeNodeSignature(const Node & anchorNode,const Node & deadNode);}\n    \\\\\n    The first argument is the anchor node, therefore the id and descriptor of\n    \\lstinline{anchorNode} are still  valid after the contraction, while\n    the  id and descriptor of \\lstinline{deadNode} become invalid.\n\n\n\\item Merge node callback :\n    A single edge contraction can lead to multiple parallel edges\n    which will be merged into single edges.\n    To merge features attached to edges, a callback vector\n    similar to the node callback vectors exists.\n    The signature is the same as for node callbacks, only with \n    edge descriptors.\n    \\\\\n    \\lstinline[language=c++]{void mergeEdgeSignature(const Edge & anchorEdge,const Edge & deadEdge);}\n    \\\\\n    Again, the first argument is the anchor, and ids and descriptors stay valid.\n    The id and descriptor of the second argument become invalid after the merge.\n\n\\item Erase edge callback :\n    The edge which is contracted is removed from the graph.\n    This callback can be used to inform data structures \n    that this edge has been removed.\n    \\\\\n    \\lstinline[language=c++]{void eraseEdgeSignature(const Edge & edge);}\n    \\\\\n    Furthermore this callback is called at the very and of each\n    edge contraction. Therefore this callback can be used\n    to indicate that all callbacks have been called and\n    the contraction is finished.\n\n\\end{compactitem}\n\n\n\n\n\n   \n\n\n\n\n\n\\subsection{Graph Algorithms} \\label{sec:graph_graph_algorithms}\n\n    \\subsubsection{Multicut}\n\n    \\subsubsection{Hierarchical Clustering}\n\n    \\begin{center}\n    \\begin{tikzpicture}[scale=0.7,transform shape]\n    \\begin{umlpackage}{Hierarchical Clustering Class Design / Class Hierarchy}\n        \\umlclass[x=-3,template=Graph]{MergeGraphAdpator}\n        {\n            \\\\// union find data structures                     \\\\\n            - edgeUfd               : IterablePartiton          \\\\\n            - nodeUfd               : IterablePartiton          \\\\ \n            - nodesAdjacency        : AdjacencySetVector        \\\\\n\n            \\\\// ref. to base graph                             \\\\\n            - baseGraph             : Graph                     \\\\\n            \\\\// callbacks                                      \\\\\n            - mergeNodeCallBacks    : MergeNodeCallBackVector   \\\\\n            - mergeEdgeCallBack     : MergeEdgeCallBackVector   \\\\\n            - eraseEdgeCallBack     : EraseEdgeCallBackVector   \\\\\n        }\n        {\n            \\\\// LEMON API for undirected graphs                \\\\\n                $\\ldots$                                        \\\\\n            \\\\// register callbacks                             \\\\ \n            + registerMergeNodeCallBack(f : MergeNodeCallBack)  \\\\\n            + registerMergeEdgeCallBack(f : MergeEdgeCallBack)  \\\\\n            + registerEraseEdgeCallBack(f : EraseEdgeCallBack)  \\\\\n\n            \\\\// modify graph                                   \\\\\n            + contractEdge(edge : Edge)     : Node              \\\\\n\n            \\\\// find representatives                           \\\\\n            + reprNode(node : Graph::Node)         : Node       \\\\\n            + reprEdge(edge : Graph::Edge)         : Edge       \\\\ \n\n            \\\\// get base graph                                 \\\\\n            + graph()                       : Graph             \\\\\n        } \n\n\n        \\umlclass[x=6,y=3,template=MergeGraph]{ClusterOperatorInterface}\n        {\n\n        }\n        {\n            \\\\// contract next edge and get weight              \\\\\n            + contractionEdge(edge : Edge)         : Edge       \\\\ \n            + contractionWeight(edge : Edge)       : Edge       \\\\\n            \\\\// get base graph                                 \\\\\n            + mergeGraph()                  : MergeGraph        \\\\\n        } \n\n\n        \\umlclass[x=9,y=-5,template=ClusterOperator]{HierarchicalClustering}\n        {\n\n        }\n        {\n            + cluster()                     : void        \\\\\n            + reprLabels(nodeMap : NodeMap) : void        \\\\      \n        } \n\n        \\umldep[geometry=-|-,name=cb]{MergeGraphAdpator}{ClusterOperatorInterface}\n        \\umldep[geometry=-|-,name=dep2]{ClusterOperatorInterface}{HierarchicalClustering}\n\n        \\umlnote[x=3,y=-3]{cb-2}{\n            ClusterOperator registers callbacks to MergeGraph\n        }\n        \n        \\umlnote[x=12,y=2]{ClusterOperatorInterface}{\n            Responsible for feature merging.\n            Finds next edge to contract. \n        }\n        \\umlnote[x=12,y=-8]{HierarchicalClustering}{\n            Encodes merge tree / dendrogram. \n        }\n\n\n    \\end{umlpackage}\n    \\end{tikzpicture}\n    \\end{center}\n\n    \\subsubsection{Watershed Algorithms}\n\n    \\subsubsection{Smoothing Algorithms}\n\n",
			"file": "thesis/Chapters/ChapterVigraGraphLibSections/SectionImpl.tex",
			"file_size": 22258,
			"file_write_time": 130411903216535786,
			"settings":
			{
				"buffer_size": 22275,
				"line_ending": "Unix"
			}
		},
		{
			"file": "thesis/Chapters/ChapterVigraGraphLibSections/graph_learning.hxx",
			"settings":
			{
				"buffer_size": 1544,
				"line_ending": "Unix"
			}
		},
		{
			"file": "thesis/Chapters/ChapterVigraGraphLibSections/SectionPython.tex",
			"settings":
			{
				"buffer_size": 16248,
				"line_ending": "Unix"
			}
		},
		{
			"file": "thesis/my-config.tex",
			"settings":
			{
				"buffer_size": 10218,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 392.0,
		"selected_items":
		[
			[
				"Latex",
				"LaTexTools: Delete temporary files"
			],
			[
				"packa",
				"Package Control: Install Package"
			],
			[
				"ins",
				"Package Control: Install Package"
			],
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"package",
				"Package Control: Install Package"
			],
			[
				"pack",
				"Package Control: Install Package"
			],
			[
				"instal",
				"Package Control: Install Package"
			],
			[
				"disab",
				"Package Control: Disable Package"
			],
			[
				"paack",
				"Package Control: Enable Package"
			],
			[
				"inst",
				"Package Control: Install Package"
			],
			[
				"Package Control: En",
				"Package Control: Enable Package"
			],
			[
				"Package Control: disa",
				"Package Control: Disable Package"
			],
			[
				"Package Control: Ins",
				"Package Control: Install Package"
			],
			[
				"packge",
				"Package Control: Install Package"
			],
			[
				"packack ",
				"Package Control: Disable Package"
			],
			[
				"pac",
				"Package Control: Enable Package"
			],
			[
				"Pack",
				"Package Control: Install Package"
			],
			[
				"",
				"Package Control: Install Package"
			],
			[
				"Package ",
				"Preferences: Browse Packages"
			],
			[
				"Snippet: ",
				"Snippet: main()"
			]
		],
		"width": 521.0
	},
	"console":
	{
		"height": 231.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)",
			" import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/home/tbeier/src/vigra/LICENSE.txt",
		"/home/tbeier/src/pyqtgraph/examples/Legend.py",
		"/home/tbeier/src/vigra/vigranumpy/src/core/learning.cxx",
		"/home/tbeier/src/vigra/vigranumpy/src/core/adjacencyListGraph.cxx",
		"/home/tbeier/src/vigra/include/vigra/merge_graph_adaptor.hxx",
		"/home/tbeier/src/pyqtgraph/examples/Arrow.py",
		"/home/tbeier/src/vigra/include/vigra/multi_array.hxx",
		"/home/tbeier/src/pyqtgraph/examples/multiprocess.py",
		"/home/tbeier/src/vigra/include/vigra/multi_labeling.hxx",
		"/home/tbeier/src/vigra/include/vigra/slanted_edge_mtf.hxx",
		"/home/tbeier/src/pyqtgraph/setup.py",
		"/home/tbeier/src/pyqtgraph/doc/source/widgets/pathbutton.rst",
		"/home/tbeier/src/pyqtgraph/pyqtgraph/widgets/PathButton.py",
		"/home/tbeier/src/vigra/doc/vigra/cgp__python_8hxx_source.html",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterVigraGraphLibSections/SectionPython.tex",
		"/home/tbeier/src/vigra/doc/vigra/python__graph__maps_8hxx_source.html",
		"/home/tbeier/src/vigra/doc/vigra/python__graph__generalization_8hxx_source.html",
		"/home/tbeier/src/vigra/doc/vigra/python__clustering__operator_8hxx_source.html",
		"/home/tbeier/src/vigra/doc/vigra/python__utility_8hxx_source.html",
		"/home/tbeier/src/vigra/doc/vigra/python__map_8hxx_source.html",
		"/home/tbeier/src/vigra/doc/vigra/PythonBindingsTutorial.html",
		"/home/tbeier/src/vigra/vigranumpy/src/core/pythonaccumulator.hxx",
		"/home/tbeier/src/vigra/include/vigra/python_utility.hxx",
		"/home/tbeier/src/vigra/include/vigra/python_graph.hxx",
		"/home/tbeier/src/pyqtgraph/pyqtgraph/python2_3.py",
		"/home/tbeier/src/pyqtgraph/tools/py2exe.bat",
		"/home/tbeier/src/vigra/docsrc/post.py",
		"/home/tbeier/src/vigra/vigranumpy/src/core/export_graph_visitor.hxx",
		"/home/tbeier/src/vigra/vigranumpy/lib/__init__.py",
		"/home/tbeier/src/masterthesis/thesis/Bibliography.bib",
		"/home/tbeier/src/masterthesis/thesis/tikzuml-v1.0b/examples/classdiag.tex",
		"/home/tbeier/Downloads/kappes.bib",
		"/home/tbeier/src/masterthesis/rapport.bib",
		"/home/tbeier/src/masterthesis/thesis/my-config.tex",
		"/home/tbeier/src/masterthesis/thesis/main.tex",
		"/home/tbeier/src/pyqtgraph/examples/GLVolumeItem.py",
		"/home/tbeier/src/pyqtgraph/examples/__main__.py",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterVigraGraphLibSections/graph_learner.hxx",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterVigraGraphLibSections/SectionGraphApis.tex",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterCgc.tex",
		"/home/tbeier/src/vigra/vigranumpy/src/core/export_graph_algorithm_visitor.hxx",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterVigrGraphLib.tex",
		"/home/tbeier/src/masterthesis/thesis/tikz-uml.sty",
		"/home/tbeier/src/super_forest.py",
		"/home/tbeier/src/vigra/vigranumpy/examples/graph_smoothing_play.py",
		"/home/tbeier/src/vigra/docsrc/image_processing.dxx",
		"/home/tbeier/src/vigra/doc/vigra/implicit__maps_8hxx_source.html",
		"/home/tbeier/src/vigra/docsrc/index.dxx",
		"/home/tbeier/src/vigra/include/vigra/graph_generalization.hxx",
		"/home/tbeier/src/masterthesis/thesis/uml/mergeGraph.xmi",
		"/home/tbeier/src/vigra/doc/vigra/mirror_tutorial_8cxx-example.html",
		"/home/tbeier/src/vigra/vigranumpy/examples/graph_smoothing.py",
		"/home/tbeier/.config/sublime-text-3/Packages/pep8_autoformat.sublime-settings",
		"/home/tbeier/src/vigra/vigranumpy/examples/graph_rag_workflow.py",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterShowcase.tex",
		"/home/tbeier/src/vigra/vigranumpy/src/core/export_graph_rag_visitor.hxx",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterRelatedWorkSections/SectionWatersheds.tex",
		"/home/tbeier/src/vigra/vigranumpy/examples/graph_eigenvalues.py",
		"/home/tbeier/src/vigra/test/convolution/lenna_gaussian_sharpening_orig.xv",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterRelatedWorkSections/SectionHCluster.tex",
		"/home/tbeier/src/masterthesis/thesis/slashbox.sty",
		"/home/tbeier/src/masterthesis/thesis/main-blx.bib",
		"/home/tbeier/src/vigra/src/examples/lenna.bmp",
		"/home/tbeier/src/vigra/src/matlab/vigraLeastAngleRegression.cpp",
		"/home/tbeier/src/masterthesis/thesis/main.pdf",
		"/home/tbeier/src/vigra/config/winsetup.iss",
		"/home/tbeier/src/vigra/include/vigra/watersheds.hxx",
		"/home/tbeier/.config/sublime-text-3/Packages/User/pep8_autoformat.sublime-settings",
		"/home/tbeier/.config/sublime-text-3/Packages/Python PEP8 Autoformat/Default (Linux).sublime-keymap",
		"/home/tbeier/src/vigra/vigranumpy/src/core/export_graph_hierarchical_clustering_visitor.hxx",
		"/home/tbeier/src/vigra/include/vigra/adjacency_list_graph.hxx",
		"/home/tbeier/src/masterthesis/thesis/FrontBackMatter/Abstract.tex",
		"/home/tbeier/src/vigra/include/vigra/graph_item_impl.hxx",
		"/home/tbeier/src/masterthesis/thesis/fig/grid.svg",
		"/home/tbeier/src/masterthesis/thesis/fig/grid_save.svg",
		"/home/tbeier/src/vigra/vigranumpy/examples/grid_graph_shortestpath.py",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterVigrGraphLib.fdb_latexmk",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterCgcWithPgf.tex",
		"/home/tbeier/src/masterthesis/thesis/classicthesis-config.tex",
		"/home/tbeier/src/vigra/docsrc/examples.dxx",
		"/home/tbeier/src/masterthesis/thesis/main.aux",
		"/home/tbeier/src/vigra/doc/vigranumpy/objects.inv",
		"/home/tbeier/src/vigra/test/classifier/data/oldsetTest.log",
		"/home/tbeier/src/vigra/include/vigra/multi_histogram.hxx",
		"/home/tbeier/src/vigra/src/examples/pyramid.cxx",
		"/home/tbeier/src/vigra/src/matlab/vigraPredictIndividually.cpp",
		"/home/tbeier/src/vigra/doc/vigra/group__RangesAndPoints.html",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterRelatedWorkSections/SectionEnergyBased.tex",
		"/home/tbeier/.config/sublime-text-3/Packages/User/Git.sublime-settings",
		"/home/tbeier/src/vigra/vigranumpy/src/core/axistags.cxx",
		"/home/tbeier/src/vigra/include/vigra/axistags.hxx",
		"/home/tbeier/.config/sublime-text-3/Packages/SideBarEnhancements/Side Bar.sublime-settings",
		"/home/tbeier/.config/sublime-text-3/Packages/Git/Git.sublime-settings",
		"/home/tbeier/.config/sublime-text-3/Packages/User/Preferences.sublime-settings",
		"/home/tbeier/src/vigra/include/vigra/iteratortraits.hxx",
		"/home/tbeier/src/vigra/include/vigra/iteratoradapter.hxx",
		"/home/tbeier/src/vigra/include/vigra/graph_maps.hxx",
		"/home/tbeier/src/vigra/include/vigra/hierarchical_clustering.hxx",
		"/home/tbeier/src/vigra/include/vigra/algorithm.hxx",
		"/home/tbeier/Desktop/lazy.bib",
		"/home/tbeier/src/masterthesis/thesis/FrontBackMatter/Contents.tex",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterRelatedWork.tex",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterVigraGraphLibSections/SectionImpl.tex",
		"/home/tbeier/src/masterthesis/thesis/Chapters/Chapter01.tex",
		"/home/tbeier/Desktop/ich",
		"/home/tbeier/src/vigra/doc/vigra/invert_tutorial_8cxx-example.html",
		"/home/tbeier/src/vigra/include/vigra/tensorutilities.hxx",
		"/home/tbeier/src/vigra/test/imagehierarchy/imagehierarchy_test.hxx",
		"/home/tbeier/src/vigra/doc/vigra/hierarchy.html",
		"/home/tbeier/src/vigra/src/impex/hdf5_rf_impex.cxx",
		"/home/tbeier/src/vigra/docsrc/header.html",
		"/home/tbeier/src/vigra/include/vigra/graph_morphology.hxx",
		"/home/tbeier/src/masterthesis/thesis/classicthesis.sty",
		"/home/tbeier/src/masterthesis/thesis/data/image-seg-b-T.data",
		"/home/tbeier/src/masterthesis/thesis/fig/illustration.svg",
		"/home/tbeier/src/masterthesis/thesis/main.tdo",
		"/home/tbeier/src/vigra/include/vigra/random_access_set.hxx",
		"/home/tbeier/src/masterthesis/README.md",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterRelatedWorkSections/SectionRandomWalker.tex",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterRelatedWorkSections/SectionMulticut.tex",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterIntroduction.tex",
		"/home/tbeier/src/masterthesis/thesis/FrontBackMatter/Dedication.tex",
		"/home/tbeier/src/masterthesis/thesis/Chapters/ChapterRag.tex",
		"/home/tbeier/src/masterthesis/thesis/Chapters/SectionEnergyBased.tex",
		"/home/tbeier/src/vigra/include/vigra/random_forest/rf_earlystopping.hxx",
		"/home/tbeier/.config/sublime-text-3/Packages/User/LaTeXTools.sublime-settings",
		"/home/tbeier/src/vigra/include/vigra/config.hxx",
		"/home/tbeier/src/vigra/doc/vigra/clustering__operator_8hxx_source.html"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 93.0,
		"where_history":
		[
			"/home/tbeier/src/masterthesis/thesis",
			"<project>",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"Graph",
			"6cm",
			"\\}",
			"8cm",
			"5cm",
			"\\\\\n",
			"href",
			"newAnchor",
			"linalg",
			"vals",
			"numpy",
			"vl",
			"resultImgLab",
			"valuesMin",
			"dwMatrix",
			"48",
			"add",
			"    // ",
			"//",
			"    // ",
			"//",
			"add",
			"    // ",
			"//",
			"7",
			"11",
			"!40",
			"70",
			"circle",
			"sloped",
			"74",
			"vId",
			"\\begin{tabular}{ l l l l l}\n%     Class & \n%         Add Nodes & \n%         Add Edges & \n%         Contract Edges & \n%         bla  \\\\\n%     Class & Add Nodes & Add Edges & Contract Edges & bla  \\\\\n%     Class & Add Nodes & Add Edges & Contract Edges & bla  \\\\ \n% \\end{tabular}",
			"\\x",
			"         ",
			"tiny",
			"smoothing",
			"gamna",
			"sigmaGRadMag",
			"slicSuper",
			"50",
			"f",
			"vigraph",
			"gradmag",
			"imgLabBig",
			"imgLabInterpolated",
			"graph",
			"class",
			"lstlisting",
			"% VIGRA uses boost python \\cite{???} to create python bindings.\n\n% To create bindings for classes or free functions glue code needs to \n% be written.\n% \\Cref{lst:boost_python} shows how a  class and free functions can\n% be exported into a python module named \\lstlisting{my_module}.\n% \\Cref{lst:boost_python_modname} defines the name of the python module.\n% In \\cref{lst:boost_python_class} we use boost \n% python to export the class \\lstlisting{Graph} with an empty\n% constructor to python, where the class is named \\lstlisting{Graph}.\n% The member function \\lstlisting{foo} of  \\lstlisting{Graph}\n% is exported in \\cref{lst:boost_python_mf}.\n% A free function can be turned into a member function\n% as shown in \\cref{lst:boost_python_emf}.\n% \\Cref{lst:boost_python_ff} shows how to export a free function.\n",
			"^^^",
			"@",
			".\n",
			"Visitor",
			"Lemon",
			"UndirectedGraph",
			"<Graph>",
			"LemonGraph",
			"EdgeMap",
			"InArcIt",
			"OutArcIt",
			"IncEdgeIt",
			"EdgeIt",
			"7",
			"ArcIt",
			"arc",
			"Arc",
			"arc",
			"Arc",
			"arc",
			"Arc",
			"arc",
			"Arc",
			"ArcIt",
			"            \\umlclass[x=0,y=0, template=$\\text{DIM,DTAG}$]{GridGraph}\n            {\n                - shape               : Shape                       \\\\\n            }\n            {\n                // Typedefs \\usp \\\\\n                + Node \\usp \\\\\n                + Edge \\usp \\\\\n                + Arc  \\usp \\\\\n                + NodeIt \\usp \\\\\n                + EdgeIt \\usp \\\\\n                + ArcIt  \\usp \\\\\n                + IncEdgeIt \\usp \\\\\n                + InArcIt   \\usp \\\\\n                + OutArcIt  \\\\\n\n                // Nested Classes  \\\\\n                + NodeMap \\nestedtemp{ValueType}   \\\\\n                +  EdgeMap \\nestedtemp{ValueType}   \\\\\n                +  ArcMap \\nestedtemp{ValueType}   \\\\\n\n                // LEMON API for undirected graphs                \\usp \\\\\n                + u(edge : Edge) : Node \\usp \\\\\n                + v(edge : Edge) : Node \\usp \\\\\n                + source(arc : Arc) : Node \\usp \\\\\n                + target(arc : Arc) : Node \\usp \\\\\n                + id(node : Node) : int \\usp \\\\\n                + id(edge : Edge) : int \\usp \\\\\n                + id(arc  : Arc)  : int \\usp \\\\\n                + nodeFromId(id : int) : Node \\usp \\\\\n                + edgeFromId(id : int) : Edge \\usp \\\\\n                + arcFromId(id  : int) : Arc  \\usp \\\\\n                + maxNodeId() : int \\usp \\\\\n                + maxEdgeId() : int \\usp \\\\\n                + maxArcId()  : int \\usp \\\\\n                + direction(arc : Arc) : bool \\usp \\\\\n                + direct(edge : Edge, naturalDirection : bool) :Arc \\usp \\\\\n                + direct(edge : Edge, node : Node) :Arc \\usp \\\\\n                + oppositeArc(arc : Arc) : Node \\usp \\\\\n                + oppositeNode(node : Node, edge : Edge) : Node \\usp \\\\\n                + baseNode(iter : IncEdgeIt) : Node \\usp \\\\\n                + runningNode(iter : IncEdgeIt) : Node \\usp \\\\\n                + baseNode(iter : OutArcIt) : Node \\usp \\\\\n                + runningNode(iter : OutArcIt) : Node \\usp \\\\\n                + baseNode(iter : InArcIt) : Node \\usp \\\\\n                + runningNode(iter : InArcIt) : Node \\\\\n\n                // Grid Graph specific API                          \\usp \\\\ \n                + GridGraph(shape : Shape, nhType : NeighborhoodType ) \n            }",
			"usnl",
			"ulnl",
			"\\\\",
			"unl",
			"InArcIt",
			"umlclass",
			"NodeMap",
			"y=3",
			"quad",
			"cb",
			"cohc",
			"α",
			"φa,b",
			")\n",
			"(",
			"TODO_ICM",
			"end",
			"ChapterVigraGraohLibSections",
			"5cm",
			"\\psi",
			"varphi",
			"gm_ef_dension",
			".\n",
			"PAMI",
			"cousty_2009_pami",
			"base",
			"G_b",
			"%\\",
			"doSomethingWithNodeFeatures",
			"}}.\n",
			"vigra",
			"Array",
			"graph",
			"graph_graph_algorithms",
			"software_lemon",
			"concept",
			"5cm",
			"0.3",
			"25",
			"3",
			".\n",
			"import",
			"import-2 ",
			"DarkRed",
			"related",
			"relatex",
			"grid33_4",
			"3",
			"0.2",
			"VIGRA_GRAPH_MAP_ALGORITHMS_HXX",
			"}\n",
			"grid",
			"blue"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"besag_1986_icm",
			"VIGRA_GRAPH_ALGORITHMS_HXX",
			"GraphAlgorithmTestSuite",
			"GraphAlgorithmTest",
			"edgeLengths",
			"nodeFeatures",
			"pyEdgeWeightedWatershedsSegmentation",
			"pyEdgeWeightedWatershedSegmentation",
			"Node",
			"VIGRA_PYTHON_GRAPH_MAPS_HXX",
			"graph1",
			"graph0",
			"vigraph.listGraph()",
			"pyRagNodeFeaturesSingleband",
			"pyRagNodeFeaturesMultiband",
			"pyEdgeWeightsFromInterpolatedImage",
			"SIZE_OF_AFFILIATED_EDGES",
			"AFFILIATED_EDGES",
			"affiliatedEdges",
			"VIGRA_EXPORT_GRAPH_RAG_VISITOR_HXX",
			"VIGRA_EXPORT_RAG_SHORTEST_PATH_VISITOR_HXX",
			"VIGRA_EXPORT_GRAPH_RAG_VISITOR_HXX",
			"leafNodeIdsAsNumpyArray",
			"VIGRA_EXPORT_GRAPH_SHORTEST_PATH_VISITOR_HXX",
			"Recursive",
			"parameter",
			"pyNodeIdsFeatures",
			"pyNodeIdsLabels",
			"resize",
			"GraphOut",
			"GraphIn",
			"edgeWeights",
			"eatureDistToEdgeWeight",
			"VIGRA_METRICS_HXX",
			"UInt32NodeArray",
			"LabelNodeArray",
			"NodeFloatMap",
			"LemonUndirectedGraphAddItemsVisitor",
			"LemonUnirectedGraphAddItemsVisitor",
			"LemonUndirectedGraphCoreVisitor",
			"pyGridGraphFelzenszwalbSegmentation",
			"neighbourId",
			"neighbour",
			"vertex_descriptor",
			"get_vertex_end_iterator",
			"get_vertex_iterator",
			"get_edge_end_iterator",
			"get_edge_iterator",
			"graph.",
			"addNode",
			"AdjacencyListGraphMergeGraphAdaptorTestSuite",
			"Graph",
			"GraphNode",
			"graph2x2_",
			"Graph",
			"GRaph",
			"AdjacencyListGraph2MergeGraphTest",
			"VIGRA_SEG_TO_SEED_HXX",
			"ArcToTargetNodeHolder",
			"VIGRA_MERGE_GRAPH_PYTHON_CLUSTERING_OPERATOR_HXX",
			"clusterOperator_",
			"MergeGraph",
			"pyHyperNodeImageFeatures",
			"nodeFeatures",
			"edgeIndicator",
			"graph",
			"EDGE_INDICATOR",
			"EDGE_INDICATOR_MAP",
			"ItemHelper",
			"HClusterMap",
			"EdgeSizeMapView",
			"EdgeIndicatorMapView",
			"VIGRA_PYTHON_GRAPH_GENERALIZATION_HXX",
			"rag",
			"edge",
			"Edge",
			"Node",
			"node",
			"Node",
			"VIGRA_ADJACENCY_LIST_GRAPH_HXX",
			"OPENGM_MCGRAPHCUT_HXX",
			"VIGRA_GRAPH_MAP_ALGORITHMS_HXX",
			"Graph",
			"ArcIteratorHolder",
			"NodeIteratorHolder",
			"EdgeIteratorHolder",
			"VIGRA_GRAPH_GENERALIZATION_HXX",
			"deleteItem",
			"ChangeablePriorityQueue",
			"g",
			"AdjacencyListGraphOffTest",
			"adjGraphSimpleTestStart1",
			"AdjacencyListGraph",
			"",
			"EdgeItInGraph",
			"EdgeItOutGraph",
			"VIGRA_NEW_RAG_HXX",
			"AdjacencyListGraphOffset1Test",
			"EdgeStorage",
			"AdjacencyListGraph<OFFSET>",
			"> >",
			"AdjacencyListGraphTestSuite",
			"GraphType",
			"adjGraph",
			"AdjacencyListGraphTest",
			"AdjacencyListGraph<OFFSET>",
			"AdjacencyListGraph<OFFSETE>",
			"GraphType",
			"AdjacencyListGraph",
			"VIGRA_DENSE_REFERENCE_MULTI_MAP_HXX",
			"VIGRA_DENSE_REFERENCE_MAP_HXX",
			"VIGRA_HIERARCHICAL_CLUSTERING_HXX",
			"HierarchicalClustering",
			"leqt",
			"VIGRA_PRIORITY_QUEUE_HXX",
			"ragMergeGridDegreeTest",
			"contractEdge",
			"//VIGRA_ASSERT_OP",
			"MergeTreeEncoding",
			"buildMergeTreeEndcoding_",
			"mergeTreeEndcoding_",
			"VIGRA_MERGE_GRAPH_VIEW_MAP_HXX",
			"UcmEdgeSizeMap",
			"edgeIndicatorMap",
			"NodeCoordinatesMap",
			"EdgeCoordinatesMap",
			"DenseReferenceMap",
			"Arc"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "thesis/Chapters/ChapterVigraGraphLibSections/SectionImpl.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 22275,
						"regions":
						{
						},
						"selection":
						[
							[
								10633,
								10633
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close"
							],
							"codeintel": true,
							"codeintel_config":
							{
								"JavaScript":
								{
									"codeintel_max_recursive_dir_depth": 2,
									"codeintel_scan_files_in_project": false,
									"javascriptExtraPaths":
									[
									]
								},
								"PHP":
								{
									"codeintel_max_recursive_dir_depth": 5,
									"codeintel_scan_files_in_project": false,
									"phpExtraPaths":
									[
									]
								},
								"Python":
								{
									"env":
									{
										"PATH": "/usr/local/bin:/usr/local/sbin:$PATH",
										"PYTHONPATH": "/usr/local/lib/python2.7/site-packages:/usr/local/lib/python:$PYTHONPATH"
									}
								}
							},
							"codeintel_enabled_languages":
							[
								"JavaScript",
								"Mason",
								"XBL",
								"XUL",
								"RHTML",
								"SCSS",
								"Python",
								"HTML",
								"Ruby",
								"Python3",
								"XML",
								"Sass",
								"XSLT",
								"Django",
								"HTML5",
								"Perl",
								"CSS",
								"Twig",
								"Less",
								"Smarty",
								"Node.js",
								"Tcl",
								"TemplateToolkit",
								"PHP"
							],
							"codeintel_live": true,
							"codeintel_live_enabled_languages":
							[
								"JavaScript",
								"Mason",
								"XBL",
								"XUL",
								"RHTML",
								"SCSS",
								"Python",
								"HTML",
								"Ruby",
								"Python3",
								"XML",
								"Sass",
								"XSLT",
								"Django",
								"HTML5",
								"Perl",
								"CSS",
								"Twig",
								"Less",
								"Smarty",
								"Node.js",
								"Tcl",
								"TemplateToolkit",
								"PHP"
							],
							"codeintel_max_recursive_dir_depth": 10,
							"codeintel_scan_exclude_dir":
							{
								"JavaScript":
								[
									"/build/",
									"/min/"
								]
							},
							"codeintel_scan_files_in_project": true,
							"codeintel_selected_catalogs":
							[
								"PyWin32",
								"jQuery",
								"Rails"
							],
							"codeintel_snippets": true,
							"codeintel_syntax_map":
							{
								"Python Django": "Python"
							},
							"codeintel_tooltips": "popup",
							"sublime_auto_complete": true,
							"syntax": "Packages/LaTeX/LaTeX.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4639.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "thesis/Chapters/ChapterVigraGraphLibSections/graph_learning.hxx",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1544,
						"regions":
						{
						},
						"selection":
						[
							[
								638,
								638
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close"
							],
							"codeintel": true,
							"codeintel_config":
							{
								"JavaScript":
								{
									"codeintel_max_recursive_dir_depth": 2,
									"codeintel_scan_files_in_project": false,
									"javascriptExtraPaths":
									[
									]
								},
								"PHP":
								{
									"codeintel_max_recursive_dir_depth": 5,
									"codeintel_scan_files_in_project": false,
									"phpExtraPaths":
									[
									]
								},
								"Python":
								{
									"env":
									{
										"PATH": "/usr/local/bin:/usr/local/sbin:$PATH",
										"PYTHONPATH": "/usr/local/lib/python2.7/site-packages:/usr/local/lib/python:$PYTHONPATH"
									}
								}
							},
							"codeintel_enabled_languages":
							[
								"JavaScript",
								"Mason",
								"XBL",
								"XUL",
								"RHTML",
								"SCSS",
								"Python",
								"HTML",
								"Ruby",
								"Python3",
								"XML",
								"Sass",
								"XSLT",
								"Django",
								"HTML5",
								"Perl",
								"CSS",
								"Twig",
								"Less",
								"Smarty",
								"Node.js",
								"Tcl",
								"TemplateToolkit",
								"PHP"
							],
							"codeintel_live": true,
							"codeintel_live_enabled_languages":
							[
								"JavaScript",
								"Mason",
								"XBL",
								"XUL",
								"RHTML",
								"SCSS",
								"Python",
								"HTML",
								"Ruby",
								"Python3",
								"XML",
								"Sass",
								"XSLT",
								"Django",
								"HTML5",
								"Perl",
								"CSS",
								"Twig",
								"Less",
								"Smarty",
								"Node.js",
								"Tcl",
								"TemplateToolkit",
								"PHP"
							],
							"codeintel_max_recursive_dir_depth": 10,
							"codeintel_scan_exclude_dir":
							{
								"JavaScript":
								[
									"/build/",
									"/min/"
								]
							},
							"codeintel_scan_files_in_project": true,
							"codeintel_selected_catalogs":
							[
								"PyWin32",
								"jQuery",
								"Rails"
							],
							"codeintel_snippets": true,
							"codeintel_syntax_map":
							{
								"Python Django": "Python"
							},
							"codeintel_tooltips": "popup",
							"sublime_auto_complete": true,
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 162.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "thesis/Chapters/ChapterVigraGraphLibSections/SectionPython.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16248,
						"regions":
						{
						},
						"selection":
						[
							[
								6319,
								6319
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close"
							],
							"syntax": "Packages/LaTeX/LaTeX.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2712.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				}
			]
		},
		{
			"sheets":
			[
				{
					"buffer": 3,
					"file": "thesis/my-config.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10218,
						"regions":
						{
						},
						"selection":
						[
							[
								9993,
								9993
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close"
							],
							"codeintel": true,
							"codeintel_config":
							{
								"JavaScript":
								{
									"codeintel_max_recursive_dir_depth": 2,
									"codeintel_scan_files_in_project": false,
									"javascriptExtraPaths":
									[
									]
								},
								"PHP":
								{
									"codeintel_max_recursive_dir_depth": 5,
									"codeintel_scan_files_in_project": false,
									"phpExtraPaths":
									[
									]
								},
								"Python":
								{
									"env":
									{
										"PATH": "/usr/local/bin:/usr/local/sbin:$PATH",
										"PYTHONPATH": "/usr/local/lib/python2.7/site-packages:/usr/local/lib/python:$PYTHONPATH"
									}
								}
							},
							"codeintel_enabled_languages":
							[
								"JavaScript",
								"Mason",
								"XBL",
								"XUL",
								"RHTML",
								"SCSS",
								"Python",
								"HTML",
								"Ruby",
								"Python3",
								"XML",
								"Sass",
								"XSLT",
								"Django",
								"HTML5",
								"Perl",
								"CSS",
								"Twig",
								"Less",
								"Smarty",
								"Node.js",
								"Tcl",
								"TemplateToolkit",
								"PHP"
							],
							"codeintel_live": true,
							"codeintel_live_enabled_languages":
							[
								"JavaScript",
								"Mason",
								"XBL",
								"XUL",
								"RHTML",
								"SCSS",
								"Python",
								"HTML",
								"Ruby",
								"Python3",
								"XML",
								"Sass",
								"XSLT",
								"Django",
								"HTML5",
								"Perl",
								"CSS",
								"Twig",
								"Less",
								"Smarty",
								"Node.js",
								"Tcl",
								"TemplateToolkit",
								"PHP"
							],
							"codeintel_max_recursive_dir_depth": 10,
							"codeintel_scan_exclude_dir":
							{
								"JavaScript":
								[
									"/build/",
									"/min/"
								]
							},
							"codeintel_scan_files_in_project": true,
							"codeintel_selected_catalogs":
							[
								"PyWin32",
								"jQuery",
								"Rails"
							],
							"codeintel_snippets": true,
							"codeintel_syntax_map":
							{
								"Python Django": "Python"
							},
							"codeintel_tooltips": "popup",
							"sublime_auto_complete": true,
							"syntax": "Packages/LaTeX/LaTeX.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7620.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 26.0
	},
	"input":
	{
		"height": 33.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.657340355497,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 266.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.unsaved_changes":
	{
		"height": 23.0
	},
	"project": "mt.sublime-project",
	"replace":
	{
		"height": 48.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
			[
				"my",
				"masterthesis/thesis/my-config.tex"
			],
			[
				"sectionp",
				"masterthesis/thesis/Chapters/ChapterVigraGraphLibSections/SectionPython.tex"
			],
			[
				"merge_gra",
				"vigra/include/vigra/merge_graph_adaptor.hxx"
			],
			[
				"impl",
				"masterthesis/thesis/Chapters/ChapterVigraGraphLibSections/SectionImpl.tex"
			],
			[
				"adaptr",
				"vigra/include/vigra/merge_graph_adaptor.hxx"
			],
			[
				"graphapi",
				"masterthesis/thesis/Chapters/ChapterVigraGraphLibSections/SectionGraphApis.tex"
			],
			[
				"bib",
				"masterthesis/thesis/Bibliography.bib"
			],
			[
				"merge",
				"vigra/include/vigra/merge_graph_adaptor.hxx"
			],
			[
				"export_rag",
				"vigra/vigranumpy/src/core/export_graph_rag_visitor.hxx"
			],
			[
				"export_gra",
				"vigra/vigranumpy/src/core/export_graph_visitor.hxx"
			],
			[
				"showca",
				"masterthesis/thesis/Chapters/ChapterShowcase.tex"
			],
			[
				"main",
				"masterthesis/thesis/main.tex"
			],
			[
				"__in",
				"vigra/vigranumpy/lib/__init__.py"
			],
			[
				"my-",
				"masterthesis/thesis/my-config.tex"
			],
			[
				"adjace",
				"vigra/vigranumpy/src/core/adjacencyListGraph.cxx"
			],
			[
				"chapterp",
				"masterthesis/thesis/Chapters/ChapterVigraGraphLibSections/SectionPython.tex"
			],
			[
				"export",
				"vigra/vigranumpy/src/core/export_graph_visitor.hxx"
			],
			[
				"graphlib",
				"masterthesis/thesis/Chapters/ChapterVigraGraphLibSections/SectionPython.tex"
			],
			[
				"apis",
				"masterthesis/thesis/Chapters/ChapterVigraGraphLibSections/SectionGraphApis.tex"
			],
			[
				"item_",
				"vigra/include/vigra/graph_item_impl.hxx"
			],
			[
				"hiera",
				"vigra/include/vigra/hierarchical_clustering.hxx"
			],
			[
				"chapter",
				"thesis/Chapters/Chapter01.tex"
			],
			[
				"graphl",
				"thesis/Chapters/ChapterVigrGraphLib.tex"
			],
			[
				"rapp",
				"masterthesis/rapport.bib"
			],
			[
				"related",
				"masterthesis/thesis/Chapters/ChapterRelatedWork.tex"
			],
			[
				"config.tex",
				"masterthesis/thesis/classicthesis-config.tex"
			],
			[
				"chaptercg",
				"masterthesis/thesis/Chapters/ChapterCgc.tex"
			],
			[
				"graph_ge",
				"vigra/include/vigra/graph_generalization.hxx"
			],
			[
				"__i",
				"play/layeredview/__init__.py"
			],
			[
				"relate",
				"masterthesis/thesis/Chapters/ChapterRelatedWork.tex"
			],
			[
				"intro",
				"masterthesis/thesis/Chapters/ChapterIntroduction.tex"
			],
			[
				"dedi",
				"masterthesis/thesis/FrontBackMatter/Dedication.tex"
			],
			[
				"chaptergra",
				"masterthesis/thesis/Chapters/ChapterVigrGraphLib.tex"
			],
			[
				"chcgc",
				"masterthesis/thesis/Chapters/ChapterCgc.tex"
			],
			[
				"myc",
				"masterthesis/thesis/my-config.tex"
			],
			[
				"chapterc",
				"masterthesis/thesis/Chapters/ChapterCgc.tex"
			],
			[
				"relatedw",
				"masterthesis/thesis/Chapters/ChapterRelatedWork.tex"
			],
			[
				"realted",
				"masterthesis/thesis/Chapters/ChapterRelatedWork.tex"
			],
			[
				"bibio",
				"masterthesis/thesis/Bibliography.bib"
			],
			[
				"chapterv",
				"masterthesis/thesis/Chapters/ChapterVigrGraphLib.tex"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 344.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
